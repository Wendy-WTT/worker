/*
题目：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
*/

/*
思路：这可以看成是升序的一个数组，那么就成为了一个二分查找问题
      如果第n个版本是好的，那么它前面所有的一定是好的；
      如果第n个版本是坏的，那么它后面所有的一定是坏的；
*/
var solution = function(isBadVersion) {
    return function(n) {
        // 1.先定义始末区间
        let left = 1, right = n
        // 2.确定循环终止条件，什么时候遍历找完
        //   这里为什么不是<=？①无论给定的n是奇数还是偶数，最后区间都会锁定两个版本，知道其中一个版本另一个不辨自证 ②当我们知道n为错时，该点下一次要做为区间端点，而n为对时，可不作为区间端点
        while (left < right) {
        // 3.定义中间值，有两种方法①(left + right) / 2 ②left + (right - left)/2防止溢出
        let mid = Math.floor(left + (right - left) / 2)
        // 4.判断如果中间值是错的，那么它后面的就不用看了都是错的，关注前面的，调整区间
            if (isBadVersion(mid)) {
                right = mid  // 或者这样想，要找的错的版本在哪个区间里，我们的目的是缩小错的区间
            }else {
                left = mid + 1
            }
        }
        // 调出循环，即left = right，区间缩为一个点，即为答案
        return left
    }
}